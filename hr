#!/usr/bin/env bash
#
# hr.sh
#
# Hanson Robotics software stack management tool

set -e

BASEDIR=$(dirname $(readlink -f ${BASH_SOURCE[0]}))
OS_VERSION=$(lsb_release --codename --short)

############# Configurations #############
DEFAULT_HR_WORKSPACE=$HOME/hansonrobotics
USER_DATA_DIR=$HOME/.hr
HR_PREFIX=/opt/hansonrobotics

HR_DEV_REPOS=(hansonrobotics/blender_api_msgs:HEAD/src hansonrobotics/blender_api:HEAD/src hansonrobotics/chatbot:HEAD/src hansonrobotics/basic_head_api:HEAD/src hansonrobotics/motors_safety:HEAD/src hansonrobotics/pau2motors:HEAD/src hansonrobotics/ros_pololu:HEAD/src hansonrobotics/webui:HEAD/src hansonrobotics/perception:HEAD/src hansonrobotics/pi_vision:HEAD/src hansonrobotics/performances:HEAD/src hansonrobotics/ros_tts:HEAD/src hansonrobotics/ttsserver:HEAD/src hansonrobotics/hr_reflexes:HEAD/src hansonrobotics/ros_face_recognition:HEAD/src hansonrobotics/hr_msgs:HEAD/src hansonrobotics/audio_stream:HEAD/src hansonrobotics/sys_monitor:HEAD/src hansonrobotics/ros_mongo:HEAD/src hansonrobotics/r2_behavior:HEAD/src hansonrobotics/eye_tracking:HEAD/src hansonrobotics/rospy_message_converter:HEAD/src hansonrobotics/realsense:HEAD/src)
HR_LAUNCHPAD_REPOS=(hansonrobotics/launchpad:)
HR_OPENCOG_DEV_REPOS=(hansonrobotics/cogutils:HROpenCog hansonrobotics/atomspace:HROpenCog hansonrobotics/opencog:HROpenCog hansonrobotics/relex:HROpenCog hansonrobotics/external-tools:HROpenCog)
OPENCOG_DEV_REPOS=(opencog/cogutil:OpenCog opencog/atomspace:OpenCog opencog/opencog:OpenCog opencog/relex:OpenCog opencog/external-tools:OpenCog)
HR_LAUNCHPAD_DIR=$HR_WORKSPACE/launchpad
HR_CONFIGS_DIR=$HR_LAUNCHPAD_DIR/configs
HR_APT_SOURCE=/etc/apt/sources.list.d/head-latest.list

if [[ $OS_VERSION == 'trusty' ]]; then
    DEPENDS_DIRS=(depends/trusty)
else
    if [[ $OS_VERSION == 'xenial' ]]; then
        DEPENDS_DIRS=(depends depends/xenial)
    fi
fi

HEAD_PACKAGES=(head-hr head-hr-ext head-hr-msgs head-saliency-tracker head-chatbot head-motor-control head-python-ttsserver head-python-pololu-motors head-marky-markov head-deps head-pocketsphinx head-festival-api head-dynamixel-motor head-webui head-blender-api head-blender-api-msgs head-ros-pololu head-motors-safety head-basic-head-api head-pau2motors head-perception head-pi-vision head-performances head-ros-misc head-ros-tts head-python-emopy head-data head-ros-emotion head-torch head-ros-audio-stream head-opencv head-tigervnc head-calib-tools head-ros-posenet)

DEFAULT_ROLE=developer
DEFAULT_GIT_PROTOCAL=https
GITHUB_STORAGE_URL=https://raw.githubusercontent.com/hansonrobotics/binary_dependency/master
GITHUB_STORAGE2_URL=https://$GITHUB_TOKEN@raw.githubusercontent.com/hansonrobotics/binary_dependency2/master
declare -A MD5SUMS

HR_ENVFILE_PATH=$USER_DATA_DIR/env.sh
HR_CACHE=$USER_DATA_DIR/cache
HR_MODELS=$USER_DATA_DIR/models

HR_PY2_VIRTUALENV=$HR_PREFIX/py2env
HR_PY3_VIRTUALENV=$HR_PREFIX/py3env
PIP2="$HR_PY2_VIRTUALENV/bin/python -m pip --disable-pip-version-check"
PIP3="$HR_PY3_VIRTUALENV/bin/python -m pip --disable-pip-version-check"
PYTHON2=$HR_PY2_VIRTUALENV/bin/python
PYTHON3=$HR_PY2_VIRTUALENV/bin/python3

if [[ -z $ROS_PKG_PREFIX ]]; then
    ROS_PKG_PREFIX=$HR_PREFIX/ros
fi

export HR_WORKSPACE
export PKG_CONFIG_PATH=${HR_PREFIX}/lib/pkgconfig:${PKG_CONFIG_PATH}
export PATH=/usr/lib/ccache:$PATH
export LC_ALL=C # for some env that has no LC_ALL

if [[ -z $ASSUME_YES ]]; then
    ASSUME_YES=0
fi

folder_to_create=($USER_DATA_DIR $HR_CACHE $HR_MODELS $HR_PREFIX $HOME/.ros)
for d in ${folder_to_create[@]}; do
    if [[ ! -d $d ]]; then
        mkdir -p $d
    fi
done

APT_GET_OPTS="-y"
############# End of Configurations #############

############# Common #############
COLOR_INFO='\033[32m'
COLOR_WARN='\033[33m'
COLOR_ERROR='\033[31m'
COLOR_RESET='\033[0m'
info() {
    printf "${COLOR_INFO}${1}${COLOR_RESET}\n" >&2
}
warn() {
    printf "${COLOR_WARN}${1}${COLOR_RESET}\n" 1>&2
}
error() {
    printf "${COLOR_ERROR}${1}${COLOR_RESET}\n" 1>&2
}
fail() {
    printf "${COLOR_ERROR}${1}${COLOR_RESET}\n" 1>&2 && return 1
}

SUDO=""
if [[ $(id -u) != 0 ]]; then
    SUDO="sudo"
fi

md5str() {
  local FNAME=$1
  case $(uname) in
    "Linux")
      echo $(md5sum "$FNAME" | cut -d ' ' -f 1)
      ;;
    "Darwin")
      echo $(md5 -q "$FNAME")
      ;;
  esac
}

checkmd5() {
    local FNAME=$1
    if [[ ! -f $FNAME ]]; then
        error "$FNAME is not a file"
        return 1
    fi
    local EXPECTED=$2
    local ACTUAL=$(md5str "$FNAME")
    if [ $EXPECTED = $ACTUAL ]; then
        info "$FNAME: successfully checked"
        return 0
    else
        error "$FNAME md5sum did not match."
        error "Expected: $EXPECTED"
        error "Actual: $ACTUAL"
        mv ${FNAME} ${FNAME}.old && warn "$FNAME is removed"
        return 1
    fi
}

timeit() {
    local start=$(date +%s.%N)
    $@
    local elapsed=$(echo "$(date +%s.%N)-$start" | bc)
    info "Time used $elapsed"
}

echo_installed_deb_package() {
    for pkg in $@; do
        local s=$(dpkg-query -W -f='${db:Status-Abbrev}=${Version}' "$pkg" 2>/dev/null)
        local ver=${s##*=}
        if [[ ${s:1:1} == 'i' ]]; then
            echo "$pkg"
        fi
    done
}

check_apt_installed() {
    # Check if the given debian packages are installed
    local pkgs=$@
    local s
    local v
    local ver
    local pkg
    for pkg in $pkgs; do
        if [[ ${pkg} == -* ]] ; then continue; fi
        if [[ ${pkg} =~ .*"=".* ]]; then
            ver=${pkg##*=}
            pkg=${pkg%=*}
            s=$(dpkg-query -W -f='${db:Status-Abbrev}=${Version}' "$pkg")
            v=${s##*=}
            s=${s%=*}
            if [[ $ver != $v || ${#s} != 3 || ${s:1:1} != 'i' ]]; then
                return 1
            else
                info "$pkg=$ver is already installed"
            fi
        else
            s=$(dpkg-query -W -f='${db:Status-Abbrev}' "$pkg")
            if [[ ${#s} != 3 || ${s:1:1} != 'i' ]]; then
                return 1
            else
                info "$pkg is already installed"
            fi
        fi
    done
}

apt_get_install() {
    if ! check_apt_installed "$@"; then
        $SUDO apt-get ${APT_GET_OPTS} install "$@" || (
            $SUDO apt-get ${APT_GET_OPTS} update &&
            $SUDO apt-get ${APT_GET_OPTS} install "$@")
    fi
}

pip2_install() {
    [[ ! -z $SUDO ]] && SUDO="$SUDO -H"
    if [[ ! -e $HR_PY2_VIRTUALENV/bin/python ]]; then
        $SUDO pip2 --disable-pip-version-check install virtualenv
        $SUDO virtualenv -p /usr/bin/python2 $HR_PY2_VIRTUALENV
    fi
    $SUDO $PIP2 install $@
}

pip2_uninstall() {
    [[ ! -z $SUDO ]] && SUDO="$SUDO -H"
    $SUDO $PIP2 uninstall $@
}

pip3_install() {
    [[ ! -z $SUDO ]] && SUDO="$SUDO -H"
    if [[ ! -e $HR_PY3_VIRTUALENV/bin/python3.6 ]]; then
        $SUDO pip2 --disable-pip-version-check install virtualenv
        $SUDO virtualenv -p /usr/bin/python3.6 $HR_PY3_VIRTUALENV
    fi
    $SUDO $PIP3 install $@
}


pip3_uninstall() {
    [[ ! -z $SUDO ]] && SUDO="$SUDO -H"
    $SUDO $PIP3 uninstall $@
}

add_ppa() {
    user=$(echo $1|cut -d: -f2|cut -d/ -f1)
    ppa=$(echo $1|cut -d: -f2|cut -d/ -f2)
    for file in `find /etc/apt/ -name \*.list`; do
        set +e
        item=$(grep -o "^deb http://ppa.launchpad.net/[a-z0-9\-]\+/[a-z0-9\-]\+" $file)
        set -e
        USER=`echo $item | cut -d/ -f4`
        PPA=`echo $item | cut -d/ -f5`
        if [[ $USER == $user && $PPA == $ppa ]]; then
            info "PPA $1 is already added"
            return 0
        fi
    done
    $SUDO add-apt-repository -y $1
}

remove_ppa() {
    $SUDO add-apt-repository -y --remove $1
}

curl_cache() {
    url=$1
    ofile=${2-${url##*/}}
    info "Downloading $(basename $1)"
    [[ -f ${HR_CACHE}/${ofile} ]] || curl -L ${url} -o ${HR_CACHE}/${ofile} || rm ${HR_CACHE}/${ofile}

    # check md5sum
    local sum=${MD5SUMS[$ofile]}
    local retry=1
    if [[ ! -z $sum ]]; then
        while (( $retry >= 0 )); do
            if checkmd5 ${HR_CACHE}/${ofile} $sum; then
                break
            fi
            retry=$((retry-1))
            echo $retry
            if (( $retry >= 0 )); then
                curl -L ${url} -o ${HR_CACHE}/${ofile}
            fi
        done
    fi

    if [[ -f ${HR_CACHE}/${ofile} ]]; then
        info "Downloading $(basename $1) is done"
    fi
}

gh_curl() {
    if [[ ! -z $GITHUB_TOKEN ]]; then
        curl -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" $@
    else
        curl -H "Accept: application/vnd.github.v3+json" $@
    fi
}

wget_cache() {
    url=$1
    ofile=${2-${url##*/}}
    info "Downloading $(basename $1)"
    [[ -f ${HR_CACHE}/${ofile} ]] || wget ${url} -O ${HR_CACHE}/${ofile} || rm ${HR_CACHE}/${ofile}

    # check md5sum
    local sum=${MD5SUMS[$ofile]}
    local retry=1
    if [[ ! -z $sum ]]; then
        while (( $retry >= 0 )); do
            if checkmd5 ${HR_CACHE}/${ofile} $sum; then
                break
            fi
            retry=$((retry-1))
            echo $retry
            if (( $retry >= 0 )); then
                wget ${url} -O ${HR_CACHE}/${ofile}
            fi
        done
    fi

    if [[ -f ${HR_CACHE}/${ofile} ]]; then
        info "Downloading $(basename $1) is done"
    fi
}

_get_confirm() {
    local message="${1:-Are you sure?}"
    local answer
    if [ "$ASSUME_YES" -eq 1 ] ; then
        confirm=1
        return
    fi
    printf "$message"
    read -r answer
    ! printf '%s\n' "$answer" | grep -Eq "$(locale yesexpr)"
    confirm=$?
}

clone() {
    owner=$1
    repo=$2
    dest=${3-"."}/$repo
    # if ssh clone failed, then try https clone
    if [[ -d $dest ]]; then
        info "$dest already exists"
    else
        info "Cloning $repo"
        local protocal=$(read_git_protocal)
        if [[ $protocal == 'ssh' ]]; then
            git clone git@github.com:$owner/$repo.git $dest
        else
            git clone https://github.com/$owner/$repo.git $dest
        fi
        info "Cloning $repo is done"
    fi
}

_set_git_protocal() {
    read_workspace >/dev/null
    local protocal=$1
    local repos=(${HR_LAUNCHPAD_REPOS[@]} ${HR_DEV_REPOS[@]} ${OPENCOG_DEV_REPOS[@]})
    local args owner repo workdir branch
    for item in ${repos[@]}; do
        mapfile -t args <<<"$(_parse_repo_string $item)"
        owner=${args[0]}
        repo=${args[1]}
        workdir=${args[2]}
        if [[ -d $workdir ]]; then
            git -C $workdir remote set-url origin $protocal${owner}/${repo}
        fi
    done
}

use_git_ssh() {
    _set_git_protocal "git@github.com:"
    if grep "export GIT_PROTOCAL" ${HR_ENVFILE_PATH} 1>/dev/null 2>&1; then
        sed -i "s#export GIT_PROTOCAL=.*#export GIT_PROTOCAL=ssh#" ${HR_ENVFILE_PATH}
    else
        echo "export GIT_PROTOCAL=ssh" >> ${HR_ENVFILE_PATH}
    fi
}

use_git_https() {
    _set_git_protocal "https://github.com/"
    if grep "export GIT_PROTOCAL" ${HR_ENVFILE_PATH} 1>/dev/null 2>&1; then
        sed -i "s#export GIT_PROTOCAL=.*#export GIT_PROTOCAL=https#" ${HR_ENVFILE_PATH}
    else
        echo "export GIT_PROTOCAL=https" >> ${HR_ENVFILE_PATH}
    fi
}

_parse_repo_string() {
    local item=$1
    local ore owner repo dest workdir
    if [[ ! $item == *:* ]]; then
        error "Invalid repository string format: $item"
        return 1
    fi
    ore=${item%:*}
    owner=${ore%/*}
    repo=${ore#*/}
    dest=$HR_WORKSPACE/${item#*:}
    workdir=${dest%/}/$repo
    echo $owner
    echo $repo
    echo $workdir
}

_get_repo() {
    local args
    mapfile -t args <<<"$(_parse_repo_string $1)"
    local owner=${args[0]}
    local repo=${args[1]}
    local workdir=${args[2]}
    clone $owner $repo $(dirname $workdir)
    if [[ -f $workdir/.gitmodules ]]; then
        git -C ${workdir} submodule sync
        git -C ${workdir} submodule update --init --recursive
    fi
}

_fetch_repo() {
    local args
    mapfile -t args <<<"$(_parse_repo_string $1)"
    local owner=${args[0]}
    local repo=${args[1]}
    local workdir=${args[2]}
    if [[ -d $workdir ]]; then
        echo "Fetching [$owner/$repo]" && git -C ${workdir} fetch
    fi
}

_update_repo() {
    local args branch
    mapfile -t args <<<"$(_parse_repo_string $1)"
    local owner=${args[0]}
    local repo=${args[1]}
    local workdir=${args[2]}
    if [[ ! -d $workdir ]]; then
        error "Can't find repo $owner:$repo"
        _get_repo $1
        return
    fi
    local prev_commit=$(git -C ${workdir} rev-parse --short HEAD)
    branch=$(git -C ${workdir} rev-parse --abbrev-ref HEAD)
    if [[ $(git -C $workdir status -uno --porcelain --ignore-submodules|wc -c) != 0 ]]; then
        warn "Updating [${owner}/${repo}] branch [${branch}] aborted."
        warn "You have unstaged change(s) $workdir" 1>&2
        echo $(git -C $workdir status -uno --porcelain --ignore-submodules) 1>&2
        return
    fi
    git -C ${workdir} rebase origin/$branch >/dev/null || (warn "Update [${repo}] failed. Abort" && if test -d "$(git -C ${workdir} rev-parse --git-path rebase-apply)"; then git -C ${workdir} rebase --abort; fi && return)
    if [[ -f ${workdir}/.gitmodules ]]; then
        git -C ${workdir} submodule sync
        git -C ${workdir} submodule update --init --recursive
    fi

    local commit=$(git -C ${workdir} rev-parse --short HEAD)
    if [[ $commit != $prev_commit ]]; then
        info "Updated [${owner}/${repo}] branch [${branch}] from $prev_commit to $commit"
    fi
}

_check_repo_changes() {
    local args repo workdir branch
    mapfile -t args <<<"$(_parse_repo_string $1)"
    repo=${args[1]}
    workdir=${args[2]}
    if [[ -d $workdir ]]; then
        branch=$(git -C $workdir rev-parse --abbrev-ref HEAD)
        if [[ $branch != 'master' ]]; then
            warn "HEAD branch is not master $(pwd)" 1>&2
            return 1
        fi
        if [[ $(git -C $workdir status -uno --porcelain|wc -c) != 0 ]]; then
            warn "Plese commit the change(s) $(pwd)" 1>&2
            warn $(git -C $workdir status --porcelain) 1>&2
            return 1
        fi
        if [[ $(git -C $workdir diff --name-only master origin/master|wc -c) != 0 ]]; then
            warn "Master branch is not synchronized with origin $(pwd)" 1>&2
            return 1
        fi
        info "Check $repo"
    fi
}

_check_deps() {
    filename="$1"
    unset PYTHONPATH
    local dir commit workdir branches curr_branch freeze freeze3
    if [[ -z $filename ]]; then
        return 1
    fi
    if [[ ! -f $filename ]]; then
        error "The filename \"$filename\" doesn't exist"
        return 1
    fi
    read_workspace >/dev/null
    if [[ -z $HR_WORKSPACE ]]; then
        error "HR_WORKSPACE is not set"
        return 1
    fi
    while read -r line
    do
        line=$(echo $line|sed -e 's/[[:space:]]*$//g;s/^[[:space:]]*//g')
        [[ -z $line ]] && continue
        [[ ${line} == \#* ]] && continue

        # check python packages
        if [[ ${line} == python* ]]; then
            local pip curr_ver package package_name required_ver satisfied
            satisfied=False
            [[ ${line} == python:* ]] && pip=$PIP2
            [[ ${line} == python2:* ]] && pip=$PIP2
            [[ ${line} == python3:* ]] && pip=$PIP3
            [[ -z $pip ]] && continue
            [[ ! -f /tmp/hr_pip_freeze ]] && $PIP2 freeze >/tmp/hr_pip_freeze
            [[ ! -f /tmp/hr_pip_freeze3 ]] && $PIP3 freeze >/tmp/hr_pip_freeze3
            [[ -z $freeze ]] && freeze=$(</tmp/hr_pip_freeze)
            [[ -z $freeze3 ]] && freeze3=$(</tmp/hr_pip_freeze3)
            package=$(echo $line|cut -d: -f2)
            if [[ $package == *=* ]]; then
                if [[ $package == *\>=* ]]; then
                    package_name=${package%\>=*}
                    required_ver=${package#*\>=}
                elif [[ $package == *==* ]]; then
                    package_name=${package%==*}
                    required_ver=${package#*==}
                fi
                if ! echo "${freeze[@]}" | grep -e "^$package_name==" &>/dev/null; then
                    error "Python package \"$package_name\" is required"
                    error "See dependency spec file $filename"
                    #return 1
                fi
                curr_ver=$(echo "${freeze[@]}"|grep -e "^$package_name=="|cut -d"=" -f3)
                if [[ $package == *\>=* ]]; then
                    satisfied=$(python -c "from pkg_resources import parse_version; print parse_version('$curr_ver') >= parse_version('$required_ver')")
                elif [[ $package == *==* ]]; then
                    satisfied=$(python -c "from pkg_resources import parse_version; print parse_version('$curr_ver') == parse_version('$required_ver')")
                fi
                if [[ $satisfied != "True" ]]; then
                    error "The version of Python package \"$package_name\" is not satisfied"
                    error "Current version \"$curr_ver\". Required version \"$required_ver\""
                    error "See dependency spec file $filename"
                    #return 1
                fi
            else
                if ! echo "${freeze[@]}" | grep -e "^$package==" &>/dev/null; then
                    error "Python package \"$package\" is required but not found"
                    error "See dependency spec file $filename"
                    #return 1
                fi
            fi
            continue
        fi

        # check debian packages
        if [[ ${line} == debian:* ]]; then
            local curr_ver package package_name required_ver satisfied
            satisfied=False
            if [[ ! -f /tmp/hr_deb_freeze ]]; then
                dpkg-query -W -f='${Package} ${Status} ${Version}\n' 2>/dev/null |grep "installed"|awk '{print $1 "==" $NF}'|sort >/tmp/hr_deb_freeze
            fi
            [[ -z $deb_freeze ]] && deb_freeze=$(</tmp/hr_deb_freeze)
            package=$(echo $line|cut -d: -f2)
            if [[ $package == *=* ]]; then
                if [[ $package == *\>=* ]]; then
                    package_name=${package%\>=*}
                    required_ver=${package#*\>=}
                elif [[ $package == *==* ]]; then
                    package_name=${package%==*}
                    required_ver=${package#*==}
                fi
                if ! echo "${deb_freeze[@]}" | grep -e "^$package_name==" &>/dev/null; then
                    error "Debian package \"$package_name\" is required"
                    error "See dependency spec file $filename"
                    [[ $package_name == head-* ]] && error "Install with command \"hr install $package_name\""
                    #return 1
                fi
                curr_ver=$(echo "${deb_freeze[@]}"|grep -e "^$package_name=="|cut -d"=" -f3)
                if [[ $package == *\>=* ]]; then
                    if dpkg --compare-versions $curr_ver ge $required_ver; then
                        satisfied=True
                    fi
                elif [[ $package == *==* ]]; then
                    if dpkg --compare-versions $curr_ver eq $required_ver; then
                        satisfied=True
                    fi
                fi
                if [[ $satisfied != "True" ]]; then
                    error "The version of Debian package \"$package_name\" is not satisfied"
                    error "Current version \"$curr_ver\". Required version \"$required_ver\""
                    error "See dependency spec file $filename"
                    [[ $package_name == head-* ]] && error "Install with command \"hr install $package_name\""
                    #return 1
                fi
            else
                if ! echo "${deb_freeze[@]}" | grep -e "^$package==" &>/dev/null; then
                    error "Debian package \"$package\" is required but not found"
                    error "See dependency spec file $filename"
                    [[ $package_name == head-* ]] && error "Install with command \"hr install $package_name\""
                    #return 1
                fi
            fi
            continue
        fi

        dir=$(echo $line|awk -F: '{print $1}')
        commit=$(echo $line|awk -F: '{print $2}')
        workdir=$HR_WORKSPACE/$dir
        if [[ ! -d $workdir ]]; then
            error "Repo \"$workdir\" doesn't exist"
            error "See dependency spec file $filename"
            #return 1
        fi
        curr_branch=$(git -C $workdir rev-parse --abbrev-ref HEAD || true)
        if [[ -z $curr_branch ]]; then
            error "Can't find branch for repo $dir"
            error "See dependency spec file $filename"
            #return 1
        fi
        if [[ -z $commit ]]; then
            continue
        fi
        branches=$(git -C $workdir branch --contains $commit 2>/dev/null | grep $curr_branch |sed 's/* //' || true)
        if [[ "$curr_branch" != "$branches" ]]; then
            error "The repo in \"$workdir\" requires $commit. Please update the repo."
            error "See dependency spec file $filename"
            #return 1
        fi
    done < "$filename"
}

_get_git() {
    if ! hash git>/dev/null 2>&1; then
        info "Installing git"
        apt_get_install git
    fi
    if ! hash git-lfs>/dev/null 2>&1; then
        info "Installing git-lfs"
        echo "deb https://packagecloud.io/github/git-lfs/ubuntu/ trusty main" | $SUDO tee /etc/apt/sources.list.d/github_git-lfs.list
        curl -L "https://packagecloud.io/github/git-lfs/gpgkey" 2> /dev/null | $SUDO apt-key add - &>/dev/null
        apt_get_install git-lfs
    fi
}

_get_repos() {
    _get_git
    git config --global credential.helper 'cache --timeout=2592000'
    local repos=$@
    for item in ${repos[@]}
    do
        _get_repo ${item}
    done
}

_update_repos() {
    local repos=$@
    for item in ${repos[@]}
    do
        _update_repo ${item}
    done
}

_check_repos_changes() {
    local repos=(${HR_LAUNCHPAD_REPOS[@]} ${HR_DEV_REPOS[@]} ${OPENCOG_DEV_REPOS[@]})
    for item in ${repos[@]}
    do
        _check_repo_changes $item
    done
}

_list_robots() {
    for f in $(find $1 -name assembly.launch); do
        echo $f | awk -F/ '/heads/{print $(NF-1)}'
    done
}

_list_bodies() {
    for f in $(find $1 -name assembly.launch); do
        echo $f | awk -F/ '/bodies/{print $(NF-1)}'
    done
}

list_robots() {
    read_workspace > /dev/null
    _list_robots $HR_CONFIGS_DIR
}

list_bodies() {
    read_workspace > /dev/null
    _list_bodies $HR_CONFIGS_DIR
}

list_installed() {
    dpkg-query -W -f='${Package} ${Status}\n' ${HEAD_PACKAGES[*]}|grep "installed"|awk '{print $1}'|sort
}

list_components() {
    if [[ $1 == 'cmd' ]]; then
        local funcs=$(compgen -A function)
        for f in ${funcs[@]}; do
            echo ${f}
        done
    else
        local funcs=$(compgen -A function|grep -E "^${1}_.*")
        for f in ${funcs[@]}; do
            echo ${f#${1}_};
        done
    fi
}

list_options() {
    if [[ $# > 0 ]]; then
        local funcs=$(compgen -A function|grep -E "^options_${1}")
        for f in ${funcs[@]}; do
            eval ${f}
        done
    fi
}

validate_component_args() {
    if [[ $# == 1 ]]; then
        eval help_${1}
        return 0
    fi
    local found_components=$(list_components $1)

    shift
    for arg in $@; do
        if [[ ${arg} == -* ]] ; then continue; fi
        local found=0
        for f in $found_components; do
            if [[ $f == $arg ]]; then
                found=1
            fi
        done
        if [[ $found == 0 ]]; then
            error "Invalid argument $arg"
            return 1
        fi
    done
    return 0
}

check_or_create_ws() {
    [[ ! -z $1 ]]
    if [[ ! -d $1 ]]; then
        local confirm
        _get_confirm "The workspace ${1} does not exist, create? [y/N]"
        if [[ ${confirm} -eq 1 ]]; then
            mkdir -p ${1}
            info "Workspace directory ${1} is created"
        fi
    fi
}

set_workspace() {
    local new_hr_workspace=${1:-$DEFAULT_HR_WORKSPACE}
    read_workspace >/dev/null || true
    if [[ ! "$new_hr_workspace" = /* ]]; then
        new_hr_workspace=$(pwd)/$new_hr_workspace
    fi
    if [[ $new_hr_workspace != '/' ]]; then
        new_hr_workspace=${new_hr_workspace%/}
    fi
    if [[ ! -z ${HR_WORKSPACE} && ${HR_WORKSPACE} != ${new_hr_workspace} ]]; then
        local confirm
        _get_confirm "The workspace is already set to ${COLOR_INFO}${HR_WORKSPACE}${COLOR_RESET}. Do you want to set to ${COLOR_WARN}${new_hr_workspace}${COLOR_RESET}? [y/N]"
        if [[ ${confirm} != 1 ]]; then
            return
        fi
    fi
    check_or_create_ws $new_hr_workspace
    if [[ ! -d $new_hr_workspace ]]; then
        error "HR workspace is incorrect"
        exit 1;
    fi
    if [[ ! -d $(dirname $HR_ENVFILE_PATH) ]]; then mkdir -p $(dirname $HR_ENVFILE_PATH); fi
    export HR_WORKSPACE=$new_hr_workspace
}

update_env_vars() {
    HR_LAUNCHPAD_DIR=$HR_WORKSPACE/launchpad
    HR_CONFIGS_DIR=$HR_WORKSPACE/launchpad/robots_config
}

read_workspace() {
    if [[ -f $HR_ENVFILE_PATH ]]; then
        local str=$(cat $HR_ENVFILE_PATH|grep "export HR_WORKSPACE=")
        if [[ -z $str ]]; then
            error "Workspace is not found in env file."
            return 1
        else
            HR_WORKSPACE=${str#export HR_WORKSPACE=}
            update_env_vars
        fi
        if [[ ! -d $HR_WORKSPACE ]]; then
            warn "Workspace ${HR_WORKSPACE} doesn't exist."
        fi
    else
        error "Workspace is not initialized."
        return 1
    fi
}

read_role() {
    local role
    if [[ -f $HR_ENVFILE_PATH ]]; then
        role=$(cat $HR_ENVFILE_PATH|grep "export HR_ROLE="|cut -d= -f2)
    fi
    if [[ -z $role ]]; then
        role=$DEFAULT_ROLE
    fi
    echo $role
}

read_git_protocal() {
    local protocal
    if [[ -f $HR_ENVFILE_PATH ]]; then
        protocal=$(cat $HR_ENVFILE_PATH|grep "export GIT_PROTOCAL="|cut -d= -f2)
    fi
    if [[ -z $protocal ]]; then
        protocal=$DEFAULT_GIT_PROTOCAL
        if [[ $protocal == 'ssh' ]]; then
            use_git_ssh
        else
            use_git_https
        fi
    fi
    echo $protocal
}

print_repo_info() {
    read_workspace >/dev/null
    local lg='git log -1 --no-merges --abbrev-commit --decorate --date=relative'
    local commit='--format=format:"%C(bold blue)%h%C(reset) %C(white)%<(50,trunc)%s%C(reset) %C(dim white)- %<(20,trunc)%an%C(reset) %C(bold green)%<(20,trunc)%ar%C(reset)"'
    local format="%-24s %-12s %-8s %s"
    local repos=(${HR_LAUNCHPAD_REPOS[@]} ${HR_DEV_REPOS[@]} ${OPENCOG_DEV_REPOS[@]})
    local item args owner repo workdir branch
    printf "${format}\n" "Repository" "Branch" "Changes" "Commit"
    for item in ${repos[@]}
    do
        mapfile -t args <<<"$(_parse_repo_string $item)"
        repo=${args[1]}
        workdir=${args[2]}
        if [[ -d $workdir ]]; then
            cd $workdir
            branch=$(git rev-parse --abbrev-ref HEAD)
            local left_right_count=$(git rev-list $branch...origin/$branch --count --left-right)
            local ahead_count=$(echo $left_right_count | cut -d" " -f1)
            local behind_count=$(echo $left_right_count | cut -d" " -f2)
            local changes=
            if (( $ahead_count > 0 )); then
                changes+="+$ahead_count"
            fi
            if (( $behind_count > 0 )); then
                changes+="-$behind_count"
            fi
            if [[ $(git status -uno --porcelain --ignore-submodules|wc -c) != 0 ]]; then
                changes+="*"
            fi
            printf "${format}\n" "$repo" "$branch" "$changes" "$(eval $lg $commit)"
        fi
    done
    echo ''
}

remove_installed_files() {
    local installed_file=$1
    if [[ -f $installed_file ]]; then
        local files=$(sort -u $installed_file)
        if [[ $ASSUME_YES == 0 ]]; then
            for f in $files; do
                echo "> $f"
            done
            local confirm
            _get_confirm "These files will be removed [y/N] "
            if [[ ${confirm} != 1 ]]; then
                exit
            fi
        fi
        for f in $files; do
            if [[ -e $f || -L $f ]]; then
                $SUDO rm $f
                info "Removed $f"
            fi
        done
        rm $installed_file
    else
        info "Nothing to remove"
    fi
}

_update_release_info() {
    local repo=$1
    local url=https://api.github.com/repos/$repo/releases
    if [[ ! -d $USER_DATA_DIR/.release ]]; then
        mkdir $USER_DATA_DIR/.release
    fi
    local release_file=$USER_DATA_DIR/.release/${repo//\//_}
    if [[ ! -z ${url} ]]; then
        gh_curl -s ${url} >$release_file
        echo "$repo" >>$USER_DATA_DIR/.release/repos
        sort -u $USER_DATA_DIR/.release/repos -o $USER_DATA_DIR/.release/repos
    fi
}

update_release_infos() {
    sort -u $USER_DATA_DIR/.release/repos -o /tmp/repos
    for repo in $(cat /tmp/repos); do
        _update_release_info $repo
    done
    rm /tmp/repos
}

_get_release_versions() {
    local repo=$1
    local prerelease=$2
    local release_file=$USER_DATA_DIR/.release/${repo//\//_}
    _update_release_info $repo
    if [[ -f $release_file ]]; then
        if [[ $prerelease == 1 ]]; then
            cat $release_file | jq -r '.[] | .tag_name'
        else
            cat $release_file | jq -r '.[] | select(.prerelease == false) | .tag_name'
        fi
    else
        error "Can't get release info"
    fi
}

get_latest_prerelease_version() {
    local repo=$1
    local versions=($(_get_release_versions ${repo} 1))
    echo ${versions}
}

get_latest_version() {
    local repo=$1
    local prerelease=$2
    if [[ $prerelease == 1 ]]; then
        get_latest_prerelease_version $repo
    else
        local url=https://api.github.com/repos/$repo/releases/latest
        if [[ ! -z ${url} ]]; then
            gh_curl -s "${url}" | jq -r 'select(.prerelease == false) | .tag_name'
        fi
    fi
}

get_release_assets() {
    local repo=$1
    local tag=$2
    local release_file=$USER_DATA_DIR/.release/${repo//\//_}
    _update_release_info $repo
    if [[ -f $release_file ]]; then
        cat $release_file | jq -r ".|map(select(.tag_name == \"$tag\"))|.[0].assets|map(.url +\"/\"+ .name)|.[]"
    else
        error "Can't get release info"
    fi
}

############# End of Common #############

############# Entries #############
hr_install() {
    validate_component_args install $@
    local options
    local args=()
    for arg in $@; do
        if [[ ${arg} == -* ]]; then
            options="$options ${arg}"
            continue;
        else
           args+=${arg}
        fi
    done
    for arg in ${args[@]}; do
        local func=install_${arg}
        info "Installing ${arg}"
        local ret=0
        ($func $options) || ret=$? && true
        if [[ $ret != 0 ]]; then
            error "Install ${arg} FAILED, return code $ret"
            return $ret
        else
            info "Install ${arg} SUCCESS"
        fi
    done
}

options_install() {
    echo "-p -f"
}

hr_uninstall() {
    validate_component_args uninstall $@
    for arg in $@; do
        local func=uninstall_${arg}
        info "Uninstalling ${arg}"
        eval $func
        if [[ $? != 0 ]]; then
            error "Uninstall ${arg} failed return code $?"
        fi
    done
}

hr_fetch() {
    read_workspace
    info "Fetching source code"
    local role=$(read_role)
    local protocal=$(read_git_protocal)
    local repos=(${HR_LAUNCHPAD_REPOS[@]})
    if [[ $role  == "developer" ]]; then
        local repos=(${repos[@]} ${HR_DEV_REPOS[@]} ${HR_OPENCOG_DEV_REPOS[@]})
    fi
    if [[ $protocal == 'ssh' ]]; then
        parallel --no-notice -j$(nproc) _fetch_repo ::: ${repos[@]}
    else
        echo "Hint: Add github ssh key 'https://help.github.com/articles/connecting-to-github-with-ssh/'"
        echo "Hint: and then run 'hr cmd use_git_ssh' to speed up"
        for repo in ${repos[@]}; do
            _fetch_repo $repo
        done
    fi
    info "Fetching source code is done"
}

hr_rebase() {
    read_workspace
    info "Rebasing HEAD source code"
    local role=$(read_role)
    local protocal=$(read_git_protocal)
    local repos=(${HR_LAUNCHPAD_REPOS[@]})
    if [[ $role  == "developer" ]]; then
        local repos=(${repos[@]} ${HR_DEV_REPOS[@]})
    fi
    _update_repos ${repos[@]}
    info "Rebasing HEAD source code is done"
}

hr_update() {
    validate_component_args update $@
    local options
    local args=()
    for arg in $@; do
        if [[ ${arg} == -* ]]; then
            options="$options ${arg}"
            continue;
        else
           args+=${arg}
        fi
    done
    for arg in ${args[@]}; do
        local func=update_${arg}
        info "Updating ${arg}"
        local ret=0
        ($func $options) || ret=$? && true
        if [[ $ret != 0 ]]; then
            error "Update ${arg} FAILED, return code $ret"
            return $ret
        else
            info "Update ${arg} SUCCESS"
        fi
    done
}

hr_build() {
    validate_component_args build $@
    for arg in $@; do
        local func=build_${arg}
        eval $func
    done
}

hr_get() {
    validate_component_args get $@
    for arg in $@; do
        local func=get_${arg}
        info "Getting ${arg}"
        eval $func
        info "${arg} is got"
    done
}

hr_clean() {
    validate_component_args clean $@
    for arg in $@; do
        local func=clean_${arg}
        info "Cleaning up ${arg}"
        eval $func
        info "${arg} is cleaned up"
    done
}

hr_cmd() {
    local func=$1
    shift
    $func $@
}

hr_init() {
    local role=$(read_role)
    local protocal=$(read_git_protocal)
    local elk_log_dir="$HOME/.hr/log/logs"
    read_workspace >/dev/null || true
    if [[ $# > 0 ]]; then
        set_workspace $@
    else
        set_workspace $HR_WORKSPACE
    fi
    echo export HR_WORKSPACE=$HR_WORKSPACE > $HR_ENVFILE_PATH
cat <<EOF >>$HR_ENVFILE_PATH
export HR_PREFIX=$HR_PREFIX
export HR_CACHE=$HR_CACHE
export HR_ROLE=$role
export GIT_PROTOCAL=$protocal

export ROS_PKG_PREFIX=$ROS_PKG_PREFIX
export ROS_LOG_DIR="$HOME/.hr/log"
export ELK_LOG_DIR="$elk_log_dir"
export PATH=$HR_PREFIX/bin:$HR_PY2_VIRTUALENV/bin:\$PATH
export LD_LIBRARY_PATH=$HR_PREFIX/lib:\$LD_LIBRARY_PATH
EOF
    info HR_WORKSPACE=$HR_WORKSPACE
    mkdir -p "$elk_log_dir"
}

hr_env() {
    if [[ -f $HR_ENVFILE_PATH ]]; then
        cat $HR_ENVFILE_PATH
    else
        error "Please run \"hr init\""
    fi
}

hr_version() {
    dpkg-query -W -f='${Package} ${Status} ${Version}\n' ${HEAD_PACKAGES[*]} 2>/dev/null |grep "installed"|awk '{print $1 "=" $NF}'|sort
    echo ''
    print_repo_info
}

hr_run() {
    hr_init
    if [[ ! -d $HR_LAUNCHPAD_DIR ]]; then
        error "Launchpad directory \"$HR_LAUNCHPAD_DIR\" doesn't exist"
        return 1
    fi
    local role=$(read_role)
    case $role in
        user)
            cd $HR_LAUNCHPAD_DIR
            ./main.sh --autoname  $@
            ;;
        developer)
            info "Starting"
            [[ -f /tmp/hr_pip_freeze ]] && rm /tmp/hr_pip_freeze
            [[ -f /tmp/hr_pip_freeze3 ]] && rm /tmp/hr_pip_freeze3
            [[ -f /tmp/hr_deb_freeze ]] && rm /tmp/hr_deb_freeze
            local repos=(${HR_LAUNCHPAD_REPOS[@]} ${HR_DEV_REPOS[@]} ${OPENCOG_DEV_REPOS[@]})
            local args owner repo workdir branch deps_dir
            for item in ${repos[@]}; do
                mapfile -t args <<<"$(_parse_repo_string $item)"
                owner=${args[0]}
                repo=${args[1]}
                workdir=${args[2]}
                for depends_dir in ${DEPENDS_DIRS[@]}; do
                    deps_dir=${workdir}/${depends_dir}
                    if [[ -d ${deps_dir} ]]; then
                        find ${deps_dir} -type f -print0 | while read -d $'\0' file
                        do
                            if [[ -f $file ]]; then
                                _check_deps $file
                            fi
                        done
                    fi
                done
            done
            [[ -f /tmp/hr_pip_freeze ]] && rm /tmp/hr_pip_freeze
            [[ -f /tmp/hr_pip_freeze3 ]] && rm /tmp/hr_pip_freeze3
            [[ -f /tmp/hr_deb_freeze ]] && rm /tmp/hr_deb_freeze
            cd $HR_LAUNCHPAD_DIR
            ./main_dev.sh --autoname $@
            ;;
        *)
            error $role
            ;;
    esac
}

hr_stop() {
    read_workspace
    if [[ ! -d $HR_LAUNCHPAD_DIR ]]; then
        error "Launchpad directory \"$HR_LAUNCHPAD_DIR\" doesn't exist"
        return 1
    fi
    cd $HR_LAUNCHPAD_DIR
    ./stop.sh $@
}

hr_role() {
    local role=$(read_role)
    info "The current role is \"${role}\""
    validate_component_args role $@
    for arg in $@; do
        local func=role_${arg}
        eval $func
        role=$(read_role)
        info "The new role is \"${role}\""
    done
}

hr_python() {
    $HR_PY2_VIRTUALENV/bin/python $@
}

hr_python3() {
    $HR_PY3_VIRTUALENV/bin/python $@
}

############# End of Entries #############

############# Functions #############
install_head() {
    _install_hr_service
    install_head-deps $@
    ssh -o StrictHostKeyChecking=no github.com 1>/dev/null 2>&1 || true
    get_models
    get_head
    local protocal=$(read_git_protocal)
    if [[ $protocal == 'ssh' ]]; then
        use_git_ssh
    else
        use_git_https
    fi
    local role=$(read_role)
    if [[ $role  == "developer" ]]; then
        build_head
    fi
}

_install_hr_service() {
    if [[ -f ${HR_PREFIX}/hrtool/hrstop.service ]]; then
        mkdir -p $HOME/.config/systemd/user
        ln -sf -T ${HR_PREFIX}/hrtool/hrstop.service $HOME/.config/systemd/user/hrstop.service
        systemctl --user daemon-reload
    else
        rm -f $HOME/.config/systemd/user/hrstop.service
    fi
}

_install_ros_indigo() {
    $SUDO sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'
    $SUDO apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net --recv-key 0xB01FA116
    local pkgs=(
        ros-indigo-desktop
        ros-indigo-tf
        ros-indigo-driver-common
        ros-indigo-cv-bridge
        ros-indigo-image-transport
        ros-indigo-openni-camera
        ros-indigo-mjpeg-server
        ros-indigo-usb-cam
        ros-indigo-dynamixel-motor
        ros-indigo-robot-state-publisher
        ros-indigo-joint-state-publisher
        ros-indigo-rosbridge-server
        python-catkin-tools
    )

    # for camera calibration
    pkgs+=(ros-indigo-image-proc)

    apt_get_install "${pkgs[@]}"

    # for blender to find ros packages
    pip3_install rospkg catkin_pkg

    if [[ ! -f /etc/ros/rosdep/sources.list.d/20-default.list ]]; then
        $SUDO rosdep init -q
        rosdep update -q
    fi
}

_install_ros_kinetic() {
    $SUDO sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'
    $SUDO apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116
    local pkgs=(
        ros-kinetic-desktop
        ros-kinetic-openni-camera
        ros-kinetic-usb-cam
        ros-kinetic-dynamixel-motor
        ros-kinetic-rosbridge-server
        python-catkin-tools
    )

    # for camera calibration
    pkgs+=(ros-kinetic-image-proc)

    apt_get_install "${pkgs[@]}"

    # for blender to find ros packages
    pip3_install rospkg catkin_pkg

    if [[ ! -f /etc/ros/rosdep/sources.list.d/20-default.list ]]; then
        $SUDO rosdep init -q
        rosdep update -q
    fi
}

_install_ros() {
    if [[ $OS_VERSION == 'trusty' ]]; then
        _install_ros_indigo
    else
        if [[ $OS_VERSION == 'xenial' ]]; then
            _install_ros_kinetic
        fi
    fi
}

install_opencog() {
    install_opencog-deps
    get_opencog
    build_opencog
}

install_opencog-deps() {
    local pkgs=(
        cmake ccache
        binutils-dev
        libboost-dev libboost-date-time-dev libboost-filesystem-dev
        libboost-program-options-dev libboost-regex-dev
        libboost-serialization-dev libboost-system-dev libboost-thread-dev
        guile-2.0-dev cython
    )
    apt_get_install "${pkgs[@]}"

    wget http://raw.github.com/opencog/ocpkg/master/ocpkg -qO octool
    chmod +rx octool
    ./octool -dpv
    rm octool

    # For sentiment analysis
    _install_nltk

    _install_relex_deps
}

_install_nltk() {
    pip2_install nltk
    $PYTHON2 -m nltk.downloader -d /usr/local/share/nltk_data punkt averaged_perceptron_tagger
}

_install_link_grammar() {
    MD5SUMS["link-grammar-5.4.2.tar.gz"]=4b9151522e12b800470c800cdf08853b
    wget_cache $GITHUB_STORAGE_URL/link-grammar-5.4.2.tar.gz
    $SUDO rm -rf /tmp/link-grammar-5.4.2
    tar -zxf ${HR_CACHE}/link-grammar-5.4.2.tar.gz -C /tmp
    mkdir -p /tmp/link-grammar-5.4.2/build
    cd /tmp/link-grammar-5.4.2/build
    JAVA_HOME=${JAVA_HOME:-/usr/lib/jvm/default-java}
    ../configure
    make -j$(nproc)
    $SUDO make install
    $SUDO ldconfig
    $SUDO rm -rf /tmp/link-grammar-5.4.2
    cd $BASEDIR
}

_install_relex_deps() {
    local pkgs=(
        build-essential python-dev swig zlib1g-dev unzip wget
        wordnet-dev wordnet-sense-index
        openjdk-7-jdk
        ant libcommons-logging-java libgetopt-java
    )
    apt_get_install "${pkgs[@]}"

    if [[ ! -e /usr/local/lib/liblink-grammar.so ]]; then
        _install_link_grammar
    fi

    # Java WordNet Library
    if [[ ! -e /usr/local/share/java/jwnl.jar ]]; then
        MD5SUMS["jwnl14-rc2.zip"]=c1c35ce1d1590938abe48d7785f87ae0
        wget_cache $GITHUB_STORAGE_URL/jwnl14-rc2.zip
        unzip -qo ${HR_CACHE}/jwnl14-rc2.zip -d /tmp jwnl14-rc2/jwnl.jar
        $SUDO mv -v /tmp/jwnl14-rc2/jwnl.jar /usr/local/share/java/
        $SUDO rm -r /tmp/jwnl14-rc2
        $SUDO chmod -v 0644 /usr/local/share/java/jwnl.jar
    fi
}

_install_ffmpeg() {
    # For blender_api_test
    add_ppa ppa:mc3man/trusty-media
    apt_get_install ffmpeg
}

_install_marytts() {
    mkdir -p ~/.hr/tts/marytts
    MD5SUMS["marytts-5.1.2.zip"]=99e774dd4c6e791ad916ae76351522f0
    wget_cache https://github.com/marytts/marytts/releases/download/v5.1.2/marytts-5.1.2.zip
    unzip -qod ~/.hr/tts/marytts ${HR_CACHE}/marytts-5.1.2.zip
}

_install_test_deps() {
    apt_get_install socat

    # WebUI compatable webserver
    $SUDO npm install xmlhttprequest --prefix $HR_WORKSPACE/HEAD/src/chatbot/scripts

    # for python test coverage
    $SUDO pip install coverage
}

_install_webui_deps() {
    # Remove npm and nodejs if needed
    # sudo npm uninstall -g npm
    # sudo apt-get remove nodejs
    if hash node>/dev/null 2>&1; then
        local ver=$(node -v)
        local major=$(echo ${ver#v} | cut -d. -f1)
        if (( $major < 8 )); then
            curl -sL https://deb.nodesource.com/setup_8.x | $SUDO -E bash -
            $SUDO apt-get install nodejs
        fi
    else
        # See https://github.com/nodesource/distributions#debinstall
        info "Installing nodejs"
        curl -sL https://deb.nodesource.com/setup_8.x | $SUDO -E bash -
        local pkg_status=$(dpkg-query -W -f='${db:Status-Abbrev}' nodejs 2>/dev/null)
        if [[ ${pkg_status:1:1} == 'i' ]]; then
            info "Removing old nodejs"
            $SUDO apt-get remove -y nodejs
        fi
        $SUDO apt-get install nodejs
        info "Installing nodejs done"
    fi
    if ! npm ls -g webpack >/dev/null; then
        $SUDO npm install -g webpack@3.X
    fi
    if ! npm ls -g nodemon >/dev/null; then
        $SUDO npm install -g nodemon
    fi
}

install_calib_tools() {
    if [[ $OS_VERSION == 'trusty' ]]; then
        MD5SUMS["maestro-linux-150116.tar.gz"]=84feed740c0695bb0eea13ccf7988b97
        wget_cache $GITHUB_STORAGE_URL/maestro-linux-150116.tar.gz
        $SUDO mkdir -p ${HR_PREFIX}/tools/maestro
        $SUDO tar zxf ${HR_CACHE}/maestro-linux-150116.tar.gz -C ${HR_PREFIX}/tools/maestro --strip-components 1
        apt_get_install libusb-1.0-0-dev mono-runtime libmono-winforms2.0-cil
        $SUDO cp ${HR_PREFIX}/tools/maestro/99-pololu.rules /etc/udev/rules.d/
        $SUDO udevadm control --reload
    elif [[ $OS_VERSION == 'xenial' ]]; then
        MD5SUMS["maestro-linux-150116.tar.gz"]=84feed740c0695bb0eea13ccf7988b97
        wget_cache $GITHUB_STORAGE_URL/maestro-linux-150116.tar.gz
        $SUDO mkdir -p ${HR_PREFIX}/tools/maestro
        $SUDO tar zxf ${HR_CACHE}/maestro-linux-150116.tar.gz -C ${HR_PREFIX}/tools/maestro --strip-components 1
        apt_get_install mono-reference-assemblies-2.0 mono-devel
        $SUDO cp ${HR_PREFIX}/tools/maestro/99-pololu.rules /etc/udev/rules.d/
        $SUDO udevadm control --reload
    fi

    MD5SUMS["mx_calib"]=5e34a64564df92c116f027a9ff48a11b
    wget_cache $GITHUB_STORAGE_URL/mx_calib
    if [[ ! -f ${HR_PREFIX}/bin/mx_calib ]]; then
        $SUDO cp ${HR_CACHE}/mx_calib ${HR_PREFIX}/bin
        $SUDO chmod +x ${HR_PREFIX}/bin/mx_calib
    fi

    apt_get_install vlc

    # install camtool
    local repo=hansonrobotics/calib_tools
    _install_latest_repo_release $@
}

_download_deb_package() {
    if [[ -z ${url} || -z $debname ]]; then
        error "requires url and debname variables"
        return 1
    fi
    curl_cache ${url} ${debname}
}

_parse_install_options() {
    while [[ $# > 0 ]]; do
        case "$1" in
            -p)
                prerelease=1
                shift
                ;;
            -f)
                force=1
                shift
                ;;
            *)
                warn "Unknown install argument $1"
                exit 1
                ;;
        esac
    done
}

_dpkg_install() {
    local debname=$1
    local output
    local name=$(basename $debname)
    if [[ ! -f $debname ]]; then
        error "Debian package $debname is not found"
        return 1
    fi
    if ! $SUDO dpkg -i "${debname}"; then
        if [[ $OS_VERSION == 'trusty' ]]; then
            $SUDO apt-get install -yf --force-yes
        else
            if [[ $OS_VERSION == 'xenial' ]]; then
                $SUDO apt-get install -yf --allow-unauthenticated
            fi
        fi
    fi

    # Check package version
    local this_pkg=$(dpkg --info "$debname"| awk '/^ Package:/{print $2}')
    local pkg_status=$(dpkg-query -W -f='${db:Status-Abbrev}=${Version}' "$this_pkg" 2>/dev/null)
    if [[ ${pkg_status:1:1} == 'i' ]]; then
        local pkg_ver=${pkg_status##*=}
        info "${name} is successfully installed, version $pkg_ver"
    else
        error "${name} is not installed."
        return 1
    fi
}

_install_deb_packages() {
    local debname=$1
    local force=$2
    if [[ ! -f "${HR_CACHE}/${debname}" ]]; then
        error "${HR_CACHE}/${debname} doesn't exist"
        return 1
    fi
    if dpkg -c "${HR_CACHE}/${debname}" >/dev/null 2>&1; then
        local this_pkg=$(dpkg --info "${HR_CACHE}/${debname}"| awk '/Package/{print $2}')
        local pkg_status=$(dpkg-query -W -f='${db:Status-Abbrev}=${Version}' "$this_pkg" 2>/dev/null)
        if [[ $force != 1 && ${pkg_status:1:1} == 'i' ]]; then
            local pkg_ver=${pkg_status##*=}
            local this_ver=$(dpkg --info "${HR_CACHE}/${debname}"| awk '/Version/{print $2}')
            if dpkg --compare-versions $pkg_ver lt $this_ver; then
                _dpkg_install "${HR_CACHE}/${debname}"
            else
                info "$this_pkg is already installed, version $pkg_ver"
            fi
        else
            _dpkg_install "${HR_CACHE}/${debname}"
        fi
    else
        error "${debname} is not debian package or broken. Please run again"
        mv "${HR_CACHE}/${debname}" "${HR_CACHE}/${debname}.bak"
        return 1
    fi
}

_install_asset() {
    local asset=$1
    local force=$2
    if [[ ! -z $asset ]]; then
        info "Asset: $asset"
        local debname=$(basename $asset)
        [[ -f ${HR_CACHE}/${debname} ]] || curl -H "Accept: application/octet-stream" -L $(dirname $asset)?access_token=$GITHUB_TOKEN -o ${HR_CACHE}/${debname} || rm ${HR_CACHE}/${debname}
        _install_deb_packages ${debname} ${force}
    else
        error "No asset"
    fi
}

_install_latest_repo_release() {
    local prerelease
    local force
    _parse_install_options $@
    local ver=$(get_latest_version $repo $prerelease)
    if [[ -z $ver ]]; then
        error "No version is found for repo \"${repo}\""
        return 1
    fi
    local assets=$(get_release_assets $repo $ver)
    if [[ ! -z $asset_name ]]; then
        for asset in ${assets[@]}; do
            if [[ $asset == *"${asset_name}"* ]]; then
                found_asset=$asset
                break
            fi
        done
        if [[ ! -z $found_asset ]]; then
            _install_asset $found_asset $force
        else
            error "Asset ${asset_name} is not found"
        fi
    else
        if [[ -z $assets ]]; then
            error "No asset is found for version $ver"
        else
            for asset in ${assets[@]}; do
                if [[ $asset == *.deb ]]; then
                    _install_asset $asset $force
                fi
            done
        fi
    fi
}

_update_head_deps() {
    hr install head-deps
}

install_head-hr() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/hrtool
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-hr_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
    install_head-hr-ext $@
}

install_head-hr-ext() {
    local repo=hansonrobotics/hrtool-ext
    _install_latest_repo_release $@
}

install_head-hr-msgs() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/hr_msgs
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-hr_msgs_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/${debname}
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-saliency-tracker() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/ros_nmpt_saliency
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-saliency-tracker_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-chatbot() {
    install_head-data $@
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/chatbot
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-chatbot_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-ros-pololu() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/ros_pololu
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-ros-pololu_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-motors-safety() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/motors_safety
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-motors-safety_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-basic-head-api() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/basic_head_api
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-basic-head-api_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-pau2motors() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/pau2motors
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-pau2motors_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-perception() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/perception
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-perception_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-pi-vision() {
    install_head-opencv $@
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/pi_vision
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-pi-vision_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-performances() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/performances
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-performances_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-ros-misc() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/ros_misc
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-ros-misc_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-python-pololu-motors() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/pololu-motors
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-python-pololu-motors_${version#v}_all.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-sound() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/sound
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-sound_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-python-ttsserver() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/ttsserver
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-python-ttsserver_${version#v}_all.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-marky-markov() {
    local prerelease
    local force
    _parse_install_options $@
    local repo=hansonrobotics/marky_markov
    local version=$(get_latest_version $repo $prerelease)
    local debname=head-marky-markov_${version#v}_amd64.deb
    local url=https://github.com/$repo/releases/download/${version}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
    $SUDO gem install marky_markov
}

install_head-deps() {
    local prerelease
    local force
    _parse_install_options $@

    $SUDO apt-get remove -y command-not-found || true # cause trouble when it's under python2 environment
    apt_get_install software-properties-common python-software-properties apt-transport-https lsb-release

    # Set primary DNS server 8.8.8.8
    # if ! grep "nameserver 8.8.8.8" /etc/resolvconf/resolv.conf.d/head; then
    #     info "Setting up DNS server 8.8.8.8"
    #     $SUDO sh -c 'echo "nameserver 8.8.8.8" >>/etc/resolvconf/resolv.conf.d/head'
    #     $SUDO resolvconf -u
    # fi
    # Remove DNS server 8.8.8.8
    if grep "nameserver 8.8.8.8" /etc/resolvconf/resolv.conf.d/head; then
        $SUDO sed -i "/nameserver 8.8.8.8/d" /etc/resolvconf/resolv.conf.d/head
        $SUDO resolvconf -u
    fi


    # setup ROS repository
    $SUDO sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'
    $SUDO apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 \
        || $SUDO apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 \
        || $SUDO apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116

    # setup HEAD repository
    #$SUDO sh -c 'echo "deb s3://dl.hansonrobotics.com stable main" > /etc/apt/sources.list.d/head-latest.list'
    $SUDO apt-key adv --keyserver keyserver.ubuntu.com --recv-keys AADAAD53

    local pkgs=(bc blender build-essential expect festival festival-dev gfortran git libatlas-base-dev libblas-dev liblapack-dev libopencv-dev openvpn portaudio19-dev pulseaudio python-bson python-catkin-pkg python-catkin-tools python-flask python-opencv python-pip python-pyaudio python-pyglet python-rospkg python-serial python-yaml python3-pip python3.6 ruby2.3 ruby2.3-dev software-properties-common swig telnet tmux wget xdotool)

    if [[ $OS_VERSION == 'trusty' ]]; then
        # https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/#install-mongodb-community-edition
        $SUDO apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6
        echo "deb [ arch=amd64 ] http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.4 multiverse" | $SUDO tee /etc/apt/sources.list.d/mongodb-org-3.4.list
        # https://packagecloud.io/github/git-lfs/install git-lfs repo
        echo "deb https://packagecloud.io/github/git-lfs/ubuntu/ trusty main" | $SUDO tee /etc/apt/sources.list.d/github_git-lfs.list
        curl -L "https://packagecloud.io/github/git-lfs/gpgkey" 2> /dev/null | $SUDO apt-key add - &>/dev/null
        # setup python2.x python3.x repository
        add_ppa ppa:fkrull/deadsnakes
        # setup ruby2.3
        add_ppa ppa:brightbox/ruby-ng
        remove_ppa ppa:irie/blender
        remove_ppa ppa:thomas-schiex/blender
        add_ppa ppa:thomas-schiex/blender-legacy

        $SUDO apt-get update

        pkgs+=(
            ros-indigo-cv-bridge
            ros-indigo-desktop
            ros-indigo-driver-common
            ros-indigo-dynamixel-motor
            ros-indigo-geometry-msgs
            ros-indigo-image-proc
            ros-indigo-image-transport
            ros-indigo-joint-state-publisher
            ros-indigo-message-runtime
            ros-indigo-mjpeg-server
            ros-indigo-openni-camera
            ros-indigo-robot-state-publisher
            ros-indigo-rosbridge-server
            ros-indigo-roscpp
            ros-indigo-rospy
            ros-indigo-sensor-msgs
            ros-indigo-std-msgs
            ros-indigo-tf
            ros-indigo-usb-cam
        )

        apt_get_install "${pkgs[@]}"
        $SUDO service mongod start

        local version=0.2.0
        local debname=head-deps-all_${version}_amd64.deb
        local url=https://github.com/hansonrobotics/binary_dependency/raw/master/$debname
        _download_deb_package
        _install_deb_packages ${debname} ${force}
        wget_cache https://raw.githubusercontent.com/hansonrobotics/HEAD/master/scripts/patch/rosbridge.patch
        $SUDO patch -N /opt/ros/indigo/lib/python2.7/dist-packages/rosbridge_library/internal/publishers.py ${HR_CACHE}/rosbridge.patch || true

    elif [[ $OS_VERSION == 'xenial' ]]; then
        # https://github.com/hansonrobotics/librealsense/blob/master/doc/distribution_linux.md
        $SUDO sh -c 'echo "deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main" > /etc/apt/sources.list.d/realsense-public.list'
        $SUDO apt-key adv --keyserver keys.gnupg.net --recv-key 6F3EFCDE

        # https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/#install-mongodb-community-edition
        $SUDO apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6
        echo "deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse" | $SUDO tee /etc/apt/sources.list.d/mongodb-org-3.4.list
        # https://packagecloud.io/github/git-lfs/install git-lfs repo
        echo "deb https://packagecloud.io/github/git-lfs/ubuntu/ xenial main" | $SUDO tee /etc/apt/sources.list.d/github_git-lfs.list
        curl -L "https://packagecloud.io/github/git-lfs/gpgkey" 2> /dev/null | $SUDO apt-key add - &>/dev/null
        add_ppa ppa:fkrull/deadsnakes
        remove_ppa ppa:irie/blender
        remove_ppa ppa:thomas-schiex/blender
        add_ppa ppa:thomas-schiex/blender-legacy

        $SUDO apt-get update

        pkgs+=(
            ros-kinetic-desktop
            ros-kinetic-dynamixel-motor
            ros-kinetic-image-proc
            ros-kinetic-opencv-apps
            ros-kinetic-openni-camera
            ros-kinetic-rosbridge-server
            ros-kinetic-usb-cam
        )
        realsense_pkgs=(
            librealsense2
            librealsense2-dkms
            librealsense2-utils
            librealsense2-dev
            librealsense2-dbg
        )
        apt_get_install "${pkgs[@]}"
        apt_get_install --upgrade "${realsense_pkgs[@]}"

        $SUDO systemctl enable mongod
        $SUDO systemctl start mongod

        local version=0.2.0
        local debname=head-deps-xenial-all_${version}_amd64.deb
        local url=https://github.com/hansonrobotics/binary_dependency/raw/master/$debname
        _download_deb_package
        _install_deb_packages ${debname} ${force}
    fi

    apt_get_install mongodb-org git-lfs openssh-server
    #$SUDO debconf-set-selections <<< 'mysql-server mysql-server/root_password password 2045'
    #$SUDO debconf-set-selections <<< 'mysql-server mysql-server/root_password_again password 2045'
    #apt_get_install mysql-server
    _install_webui_deps

    $SUDO /usr/bin/python -m pip --disable-pip-version-check install python-json-logger # for ROS logging

    # for blender to find ros packages
    pip3_install rospkg catkin_pkg==0.4.9 numpy pyyaml python-json-logger
    pip2_install \
        rospkg catkin_pkg==0.4.9 pyyaml numpy pandas scipy num2words \
        pyparsing transitions flask EasyProcess \
        psutil natsort apiai numexpr \
        future six \
        MySQL-python SQLAlchemy \
        bs4 xlrd Babel progressbar2 python-json-logger

    pip2_install python-dateutil --upgrade

    install_head-hr-msgs $@
    install_head-saliency-tracker $@
    install_head-chatbot $@
    install_head-pocketsphinx $@
    install_head-ros-audio-stream $@ # depends on head-pocketsphinx
    install_head-python-ttsserver $@
    install_head-python-pololu-motors $@
    install_head-marky-markov $@
    install_head-festival-api $@
    #install_head-dynamixel-motor $@
    install_head-webui $@
    install_head-blender-api $@
    install_head-blender-api-msgs $@
    install_head-ros-pololu $@
    install_head-motors-safety $@
    install_head-basic-head-api $@
    install_head-pau2motors $@
    install_head-perception $@
    #install_head-pi-vision $@
    install_head-performances $@
    install_head-ros-misc $@
    install_head-ros-tts $@
    #install_head-ros-emotion $@
    install_head-python-dynamixel-lib $@
    install_elasticsearch $@
    if [[ $OS_VERSION == 'xenial' ]]; then
        uninstall_head-librealsense $@ || true
    fi
    install_calib_tools $@
    install_head-ros-posenet $@
}

install_head-sphinxbase() {
    local repo=hansonrobotics/sphinxbase
    _install_latest_repo_release $@
}

install_head-pocketsphinx() {
    install_head-sphinxbase $@
    local repo=hansonrobotics/pocketsphinx
    _install_latest_repo_release $@
}

install_head-festival-api() {
    local prerelease
    local force
    _parse_install_options $@
    local version=v0.1.6
    local debname=head-festival-api_${version#v}_amd64.deb
    local url=$GITHUB_STORAGE_URL/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-dynamixel-motor() {
    local repo=hansonrobotics/dynamixel_motor
    _install_latest_repo_release $@
}

install_head-webui() {
    local repo=hansonrobotics/webui
    _install_latest_repo_release $@
}

install_head-blender-api() {
    local repo=hansonrobotics/blender_api
    _install_latest_repo_release $@
}

install_head-blender-api-msgs() {
    local repo=hansonrobotics/blender_api_msgs
    _install_latest_repo_release $@
}

install_head-ros-tts() {
    local repo=hansonrobotics/ros_tts
    _install_latest_repo_release $@
}

install_head-python-emopy() {
    local repo=hansonrobotics/emopy
    _install_latest_repo_release $@
}

install_head-data() {
    local prerelease
    local force
    _parse_install_options $@
    local version=0.1.0
    local debname=head-data_${version}_amd64.deb
    local url=${GITHUB_STORAGE_URL}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-ros-emotion() {
    install_head-python-emopy $@
    local repo=hansonrobotics/ros_emotion
    _install_latest_repo_release $@
}

install_head-torch() {
    local repo=hansonrobotics/distro
    _install_latest_repo_release $@
}

install_head-python-openface() {
    local repo=hansonrobotics/openface
    _install_latest_repo_release $@
}

install_head-ros-face-recognition() {
    install_head-python-openface $@
    local repo=hansonrobotics/ros_face_recognition
    _install_latest_repo_release $@
}

install_head-ros-audio-stream() {
    uninstall_head-sound || true
    local repo=hansonrobotics/audio_stream
    _install_latest_repo_release $@
}

install_head-python-dynamixel-lib() {
    local repo=hansonrobotics/DynamixelSDK
    _install_latest_repo_release $@
}

install_head-opencv() {
    local prerelease
    local force
    _parse_install_options $@
    local version=2.4.13
    local debname=head-opencv_${version}_amd64.deb
    local url=https://github.com/hansonrobotics/binary_dependency/raw/master/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-librealsense() {
    local repo=hansonrobotics/realsense
    _install_latest_repo_release $@
}

install_obs() {
    $SUDO apt-get install ffmpeg
    $SUDO add-apt-repository ppa:obsproject/obs-studio
    $SUDO apt-get update
    $SUDO apt-get install obs-studio
}

install_oracle-jdk8() {
    if [[ ! -f /usr/lib/jvm/java-8-oracle/bin/javac ]]; then
        $SUDO apt-get install -y python-software-properties debconf-utils
        $SUDO add-apt-repository -y ppa:webupd8team/java
        $SUDO apt-get update
        $SUDO debconf-set-selections <<< "oracle-java8-installer shared/accepted-oracle-license-v1-1 select true"
        $SUDO apt-get install -y oracle-java8-installer oracle-java8-set-default
    else
        info "Oracle JDK8 has already been installed"
    fi
}

install_elasticsearch() {
    install_oracle-jdk8
    if [[ ! -f /usr/share/elasticsearch/bin/elasticsearch ]]; then
        MD5SUMS["elasticsearch-oss-6.3.0.deb"]=c113c8c0789881d1b6208daa9a4e9d7c
        local url=${GITHUB_STORAGE_URL}/elasticsearch-oss-6.3.0.deb
        curl_cache ${url}
        $SUDO dpkg -i ${HR_CACHE}/elasticsearch-oss-6.3.0.deb
    else
        info "ElasticSearch has already been installed"
    fi
    # ps -p 1
    if [[ $OS_VERSION == 'trusty' ]]; then
        $SUDO update-rc.d elasticsearch defaults 95 10
        $SUDO -i service elasticsearch start
    elif [[ $OS_VERSION == 'xenial' ]]; then
        $SUDO systemctl daemon-reload
        $SUDO systemctl enable elasticsearch.service
        $SUDO systemctl start elasticsearch
    fi
    $SUDO $PIP2 install "elasticsearch>=6.2.0,<7.0.0"
}

install_kibana() {
    if [[ ! -f /usr/share/kibana/bin/kibana ]]; then
        local url=https://artifacts.elastic.co/downloads/kibana/kibana-6.3.0-amd64.deb
        curl_cache ${url}
        $SUDO dpkg -i ${HR_CACHE}/kibana-6.3.0-amd64.deb
    else
        info "Kibana has already been installed"
    fi

    if [[ $OS_VERSION == 'trusty' ]]; then
        $SUDO update-rc.d kibana defaults 95 10
        $SUDO -i service kibana start
    elif [[ $OS_VERSION == 'xenial' ]]; then
        $SUDO systemctl daemon-reload
        $SUDO systemctl enable kibana.service
        $SUDO systemctl start kibana
    fi
}

install_postgresql() {
    $SUDO add-apt-repository -y 'deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main'
    wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | $SUDO apt-key add -
    $SUDO apt-get update
    $SUDO apt-get install -y postgresql-10
    $SUDO $PIP2 install "psycopg2-binary"
    $SUDO -u postgres createuser hr
    $SUDO -u postgres createdb hr
    $SUDO curl -o /etc/postgresql/10/main/pg_hba.conf https://raw.githubusercontent.com/hansonrobotics/hrtool/master/conf/pg_hba.conf
    $SUDO chown postgres:postgres /etc/postgresql/10/main/pg_hba.conf
    $SUDO service postgresql restart
}

install_head-tigervnc() {
    local prerelease
    local force
    _parse_install_options $@
    local version=1.8.0
    local debname=head-tigervnc_${version}_amd64.deb
    local url=${GITHUB_STORAGE_URL}/$debname
    _download_deb_package
    _install_deb_packages ${debname} ${force}
}

install_head-ros-posenet() {
    local repo=hansonrobotics/ros_posenet
    _install_latest_repo_release $@
}

help_install() {
cat << EOF
hr install <dependency> [<dependency>] ...

Install dependencies

    all                     Install HEAD and its depencencies, OpenCog and its dependencies
    head                    Install HEAD and its depencencies
    opencog                 Install OpenCog and its dependencies
    head-deps               Install HEAD dependencies
    opencog-deps            Install OpenCog dependencies
    head-hr-msgs            Install hr_msgs, a shared set of ROS messages for HR
    head-hr-ext             Install hr tool extension
    head-chatbot            Install chatbot
    head-saliency-tracker   Install saliency tracker
    head-sound              Install sound tools
    head-python-ttsserver   Install tts server
    head-marky-markov       Install marky markov
    ...                     ...

Options

    -p      Install pre-release package
    -f      Force install

EOF
}

uninstall_head-hr() {
    $SUDO apt-get remove head-hr
}

uninstall_head-hr-ext() {
    $SUDO apt-get remove head-hr-ext
}

uninstall_head-hr-msgs() {
    $SUDO apt-get remove head-hr-msgs
}

uninstall_head-chatbot() {
    $SUDO apt-get remove head-chatbot
}

uninstall_head-saliency-tracker() {
    $SUDO apt-get remove head-saliency-tracker
}

uninstall_head-motor-control() {
    $SUDO apt-get remove head-motor-control
}

uninstall_head-python-pololu-motors() {
    $SUDO apt-get remove head-python-pololu-motors
}

uninstall_head-sound() {
    $SUDO apt-get remove head-sound
}

uninstall_head-python-ttsserver() {
    $SUDO apt-get remove head-python-ttsserver
}

uninstall_head-marky-markov() {
    $SUDO apt-get remove head-marky-markov
}

uninstall_head-deps() {
    $SUDO apt-get remove -y head-deps-all

    #remove_ppa ppa:brightbox/ruby-ng
    #remove_ppa ppa:fkrull/deadsnakes

    #$SUDO npm uninstall -g nodemon
    #$SUDO npm uninstall -g webpack

    #sudo apt-get remove -y nodejs

    pip2_uninstall numpy pandas scipy num2words pinyin==0.2.5 pyparsing transitions flask EasyProcess psutil natsort
}

uninstall_head-sphinxbase() {
    $SUDO apt-get remove head-sphinxbase
}

uninstall_head-pocketsphinx() {
    uninstall_head-sphinxbase
    $SUDO apt-get remove head-pocketsphinx
}

uninstall_head-festival-api() {
    $SUDO apt-get remove head-festival-api
}

uninstall_head-dynamixel-motor() {
    $SUDO apt-get remove head-dynamixel-motor
}

uninstall_head-webui() {
    $SUDO apt-get remove head-webui
}

uninstall_head-blender-api() {
    $SUDO apt-get remove head-blender-api
}

uninstall_head-blender-api-msgs() {
    $SUDO apt-get remove head-blender-api-msgs
}

uninstall_head-ros-pololu() {
    $SUDO apt-get remove head-ros-pololu
}

uninstall_head-motors-safety() {
    $SUDO apt-get remove head-motors-safety
}

uninstall_head-basic-head-api() {
    $SUDO apt-get remove head-basic-head-api
}

uninstall_head-pau2motors() {
    $SUDO apt-get remove head-pau2motors
}

uninstall_head-perception() {
    $SUDO apt-get remove head-perception
}

uninstall_head-pi-vision() {
    $SUDO apt-get remove head-pi-vision
}

uninstall_head-performances() {
    $SUDO apt-get remove head-performances
}

uninstall_head-ros-misc() {
    $SUDO apt-get remove head-ros-misc
}

uninstall_head-ros-tts() {
    $SUDO apt-get remove head-ros-tts
}

uninstall_head-python-emopy() {
    uninstall_head-ros-emotion
    $SUDO apt-get remove head-python-emopy
}

uninstall_head-data() {
    $SUDO apt-get remove head-data
}

uninstall_head-ros-emotion() {
    $SUDO apt-get remove head-ros-emotion
}

uninstall_head-torch() {
    $SUDO apt-get remove head-torch
}

uninstall_head-python-openface() {
    $SUDO apt-get remove head-python-openface
}

uninstall_head-ros-face-recognition() {
    $SUDO apt-get remove head-ros-face-recognition
}

uninstall_head-ros-audio-stream() {
    $SUDO apt-get remove head-ros-audio-stream
}

uninstall_head-opencv() {
    $SUDO apt-get remove head-opencv
}

uninstall_head-librealsense() {
    $SUDO apt-get remove head-librealsense
}

uninstall_head-tigervnc() {
    $SUDO apt-get remove head-tigervnc
}

uninstall_head-ros-posenet() {
    $SUDO apt-get remove head-ros-posenet
}


help_uninstall() {
cat << EOF
hr uninstall <component> [<component>] ...

Uninstall components

    head-hr                 Uninstall hr tool
    head-hr-ext             Uninstall hr-ext
    head-hr-msgs            Uninstall hr_msgs
    head-chatbot            Uninstall chatbot
    head-saliency-tracker   Uninstall saliency tracker
    head-motor-control      Uninstall motor control
    head-sound              Uninstall sound tools
    head-python-ttsserver   Uninstall tts server
    head-marky-markov       Uninstall marky markov
EOF
}

update_head() {
    read_workspace
    info "Updating HEAD source code"
    local role=$(read_role)
    local protocal=$(read_git_protocal)
    local repos=(${HR_LAUNCHPAD_REPOS[@]})
    if [[ $role  == "developer" ]]; then
        local repos=(${repos[@]} ${HR_DEV_REPOS[@]})
    fi
    if [[ $protocal == 'ssh' ]]; then
        parallel --no-notice -j$(nproc) _fetch_repo ::: ${repos[@]}
    else
        echo "Hint: Add github ssh key 'https://help.github.com/articles/connecting-to-github-with-ssh/'"
        echo "Hint: and then run 'hr cmd use_git_ssh' to speed up"
        for repo in ${repos[@]}; do
            _fetch_repo $repo
        done
    fi
    _update_repos ${repos[@]}
    info "Updating HEAD source code is done"
}

update_full_head() {
    # Experimental
    [[ -f ${HR_PREFIX}/hrtool/update.sh ]] && source ${HR_PREFIX}/hrtool/update.sh && _update_full_head $@
}

update_opencog() {
    read_workspace
    info "Updating OpenCog source code"
    parallel --no-notice -j$(nproc) _fetch_repo ::: ${OPENCOG_DEV_REPOS[@]}
    _update_repos ${OPENCOG_DEV_REPOS[@]}
    info "Updating OpenCog source code is done"
}

help_update() {
cat << EOF
hr update <component> [<component>] ...

Update components

    head        Update HEAD source code
    opencog     Update OpenCog source code
    full_head   Update the whole HEAD stack including hrtool, dependencies, and source code.  Can add option such as "-p" to install prerelease packages.
EOF
}

get_opencog() {
    read_workspace || hr_init
    git config --global credential.helper 'cache --timeout=86400'
     _get_repos ${OPENCOG_DEV_REPOS[@]}
    #parallel _get_repo ::: ${OPENCOG_DEV_REPOS[@]}
}

get_head() {
    read_workspace || hr_init
    local role=$(read_role)
    local repos=(${HR_LAUNCHPAD_REPOS[@]})
    if [[ $role  == "developer" ]]; then
        repos=(${repos[@]} ${HR_DEV_REPOS[@]})
    fi
    _get_repos ${repos[@]}
    #parallel _get_repo ::: ${repos[@]}
}

get_hropencog() {
    read_workspace || hr_init
    git config --global credential.helper 'cache --timeout=86400'
     _get_repos ${HR_OPENCOG_DEV_REPOS[@]}
}

_get_openface_models() {
    MD5SUMS["nn4.small2.v1.t7"]=c95bfd8cc1adf05210e979ff623013b6
    MD5SUMS["celeb-classifier.nn4.small2.v1.pkl"]=199a2c0d32fd0f22f14ad2d248280475
    MD5SUMS["shape_predictor_68_face_landmarks.dat.bz2"]=677a91476056de0507f1915adc7ef86a
    wget_cache $GITHUB_STORAGE_URL/models/nn4.small2.v1.t7
    wget_cache $GITHUB_STORAGE_URL/models/celeb-classifier.nn4.small2.v1.pkl
    if [[ ! -f ${HR_CACHE}/shape_predictor_68_face_landmarks.dat ]]; then
        wget_cache $GITHUB_STORAGE_URL/models/shape_predictor_68_face_landmarks.dat.bz2
        bunzip2 -f ${HR_CACHE}/shape_predictor_68_face_landmarks.dat.bz2
    else
        info "shape_predictor_68_face_landmarks.dat already exists"
    fi
    cp ${HR_CACHE}/shape_predictor_68_face_landmarks.dat ${HR_MODELS}
    cp ${HR_CACHE}/nn4.small2.v1.t7 ${HR_MODELS}
    cp ${HR_CACHE}/celeb-classifier.nn4.small2.v1.pkl ${HR_MODELS}
}

_get_marky_markov_models() {
    wget_cache https://github.com/opencog/test-datasets/releases/download/current/markov_modeling.tar.gz
    checkmd5 ${HR_CACHE}/markov_modeling.tar.gz 7d51bbcd4df89b2633bd9520fb99b2b7
    mkdir -p $HR_MODELS/markov_modeling
    tar zxf ${HR_CACHE}/markov_modeling.tar.gz -C $HR_MODELS/markov_modeling
}

get_models() {
    _get_openface_models
    _get_marky_markov_models
}

help_get() {
cat << EOF
hr get <component> [<component>] ...

Download components

    head        Download HEAD repositories
    opencog     Download OpenCog repositories
    models      Download models for dlib landmarks, markov text generator, etc.
    voices      Download TTS voices
EOF
}

_build_head() {
    read_workspace
    cd $HR_WORKSPACE/HEAD
    if [[ $OS_VERSION == 'trusty' ]]; then
        source /opt/ros/indigo/setup.bash
    else
        if [[ $OS_VERSION == 'xenial' ]]; then
            source /opt/ros/kinetic/setup.bash
        fi
    fi
    source $ROS_PKG_PREFIX/setup.bash
    if [[ ! -d .catkin_tools ]]; then
        catkin init
    fi

    if [[ $# > 0 ]]; then
        catkin config --blacklist $@
    fi
    catkin build --force-cmake -j$(nproc) --no-status --make-args install
    build_head_python
}

build_head_python() {
    read_workspace
    TARGET=$HR_WORKSPACE/HEAD/devel/lib/python2.7/dist-packages
    rm -rf $TARGET/roscom*
    info "Installing blender roscom"
    PYTHONPATH= $PIP3 install -t $TARGET $HR_WORKSPACE/HEAD/src/blender_api_msgs --no-deps

    rm -rf $TARGET/ttsserver*
    info "Installing ttsserver"
    $PIP2 install -t $TARGET $HR_WORKSPACE/HEAD/src/ttsserver --no-deps --upgrade
}

build_head() {
    local blacklist=(
        audio_tools
        cmt_tracker
        cmt_tracker_msgs
        emotime
        eva_behavior
        face_id
        face_recognition
        manyears_msgs
        manyears_ros
        rt_audio_ros
        speech2command
        icog_face_tracker
        pi_vision
        pi_face_tracker_gui
    )

    if [[ ${OS_VERSION} == "trusty" ]]; then
        blacklist+=(cv_bridge)
    elif [[ ${OS_VERSION} == "xenial" ]]; then
        blacklist+=(pi_face_tracker ros2opencv)
    fi

    _build_head ${blacklist[@]}
    _build_webui-js
}

_build_webui-js() {
    read_workspace
    if [[ -d $HR_WORKSPACE/HEAD/src/webui ]]; then
        cd $HR_WORKSPACE/HEAD/src/webui
        npm install
    fi
}

_build_full-head() {
    local blacklist=(
        eva_behavior
        speech2command
        testing_tools
        icog_face_tracker
    )
    _build_head ${blacklist[@]}
}

build_opencog() {
    read_workspace
    local args repo workdir
    for item in ${OPENCOG_DEV_REPOS[*]}
    do
        mapfile -t args <<<"$(_parse_repo_string $item)"
        repo=${args[1]}
        workdir=${args[2]}
        if [[ $repo != 'relex' && \
              $repo != 'external-tools' ]]; then
            if [[ ! -d $workdir/build ]]; then
                mkdir $workdir/build
            fi
            cd $workdir/build && cmake ..  && make -j$(nproc) && $SUDO make install
        fi
        if [[ $repo == 'relex' ]]; then
            cd $workdir && JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF8 ant build && $SUDO ant install
        fi
    done
}

help_build() {
cat << EOF
hr build <component> [<component>] ...

Build components

    head            Build only whitelist packages HEAD
    opencog         Build OpenCog components
    head_python     Build HEAD python packages
    roodle          Build roodle
    ros_posenet-js  Build posenet

EOF
}

clean_head() {
    read_workspace
    cd $HR_WORKSPACE/HEAD
    if [[ -d .catkin_tools ]]; then
        catkin clean -y || catkin clean -a
    fi

    # Check if there is unnecessary packages at HEAD/src
    local workdirs=()
    for item in ${HR_DEV_REPOS[*]}
    do
        mapfile -t args <<<"$(_parse_repo_string $item)"
        workdirs=(${workdirs[*]} ${args[2]})
    done
    for d in $(find $HR_WORKSPACE/HEAD/src -maxdepth 1 -mindepth 1 -type d ); do
        if [[ ! " ${workdirs[@]} " =~ " ${d} " ]]; then
            local confirm
            _get_confirm "${COLOR_WARN}\nUnofficial repository is found. You can remove it if you know what it does. \n⤷ ${d}\n\nDo you want to remove it? [y/N]${COLOR_RESET}"
            if [[ ${confirm} == 1 ]]; then
                chmod -R +w ${d}
                rm -r $d
            fi
        fi
    done
}

clean_opencog() {
    read_workspace
    local item args repo workdir
    rm -rf ~/.cache/guile
    rm -rf ~/.hr/cache/oc_aiml
    if [[ ! -z $HR_WORKSPACE ]]; then
        for item in ${OPENCOG_DEV_REPOS[*]}
        do
            mapfile -t args <<<"$(_parse_repo_string $item)"
            repo=${args[1]}
            workdir=${args[2]}
            if [[ $repo != 'relex' && $repo != 'external-tools' ]]; then
                $SUDO rm -rf $workdir/build
            fi
        done
    fi
    $SUDO rm -rf /usr/local/include/opencog
    $SUDO rm -rf /usr/local/lib/opencog
    $SUDO rm -rf /usr/local/share/opencog
    $SUDO rm -f /usr/local/bin/cogserver
    $SUDO rm -f /usr/local/etc/cogserver.conf
    $SUDO rm -f /usr/local/etc/opencog.conf
    $SUDO rm -f /usr/local/lib/libcogutil.so
}

help_clean() {
cat << EOF
hr clean <component> [<component>] ...

Clean up components

    head    Clean up HEAD builds
    opencog Clean up OpenCog builds, cache and models
EOF
}

help_cmd() {
cat << EOF
hr cmd <command> [args]

EOF
}

role_user() {
    if grep "export HR_ROLE" ${HR_ENVFILE_PATH} 1>/dev/null 2>&1; then
        sed -i "s#export HR_ROLE=.*#export HR_ROLE=user#" ${HR_ENVFILE_PATH}
    else
        echo "export HR_ROLE=user" >> ${HR_ENVFILE_PATH}
    fi
}

role_developer() {
    if grep "export HR_ROLE" ${HR_ENVFILE_PATH} 1>/dev/null 2>&1; then
        sed -i "s#export HR_ROLE=.*#export HR_ROLE=developer#" ${HR_ENVFILE_PATH}
    else
        echo "export HR_ROLE=developer" >> ${HR_ENVFILE_PATH}
    fi
}

help_role() {
cat << EOF
hr role <command> [args]

Some useful commands:

    user        Go to user role. Under this role, you run the released stack.
    developer   Go to developer role. Under this role, you download the source code and build the stack locally, and run this local stack.

EOF
}

create_depends() {
    local branch_name=$1
    if [[ -z $branch_name ]]; then
        error "Please provide branch name"
        return 1
    fi
    read_workspace
    local role=$(read_role)
    if [[ $role != 'developer' ]]; then
        error "Should be in developer mode"
        return 1
    fi
    local dep_file=/tmp/${branch_name}.deps
    >$dep_file
    local repos=(${HR_LAUNCHPAD_REPOS[@]} ${HR_DEV_REPOS[@]})
    local args owner repo workdir branch tag
    for item in ${repos[@]}; do
        mapfile -t args <<<"$(_parse_repo_string $item)"
        owner=${args[0]}
        repo=${args[1]}
        workdir=${args[2]}
        tag=${item#*:}/$repo
        tag=${tag#/}
        if [[ -d $workdir ]]; then
            branch=$(git -C ${workdir} rev-parse --abbrev-ref HEAD)
            if [[ $branch == $branch_name ]]; then
                echo ${tag}:$(git -C $workdir rev-parse HEAD) >>${dep_file}
            fi
        fi
    done
    if [[ -s ${dep_file} ]]; then
        cat ${dep_file}
    else
        warn "No depends are found"
    fi
    rm ${dep_file}
}

push_repos() {
    local branch_name=$1
    if [[ -z $branch_name ]]; then
        error "Please provide branch name you want to push"
        return 1
    fi
    read_workspace
    local role=$(read_role)
    if [[ $role != 'developer' ]]; then
        error "Should be in developer mode"
        return 1
    fi
    local repos=(${HR_LAUNCHPAD_REPOS[@]} ${HR_DEV_REPOS[@]})
    local args owner repo workdir branch
    local push=0
    for item in ${repos[@]}; do
        mapfile -t args <<<"$(_parse_repo_string $item)"
        owner=${args[0]}
        repo=${args[1]}
        workdir=${args[2]}
        if [[ -d $workdir ]]; then
            branch=$(git -C ${workdir} rev-parse --abbrev-ref HEAD)
            if [[ $branch == $branch_name ]]; then
                info "Pushing $repo[$branch_name]"
                git -C $workdir push origin $branch_name:$branch_name
                info "$repo[$branch_name] has been pushed to GitHub"
                push=1
            fi
        fi
    done
    if [[ $push == 0 ]]; then
        warn "No any repository has branch named $branch_name"
    fi
}

checkout_repos() {
    local branch_name=$1
    if [[ -z $branch_name ]]; then
        error "Please provide branch name you want to push"
        return 1
    fi
    read_workspace
    local role=$(read_role)
    if [[ $role != 'developer' ]]; then
        error "Should be in developer mode"
        return 1
    fi
    local repos=(${HR_LAUNCHPAD_REPOS[@]} ${HR_DEV_REPOS[@]})
    local args owner repo workdir branch
    local checked=0
    for item in ${repos[@]}; do
        mapfile -t args <<<"$(_parse_repo_string $item)"
        owner=${args[0]}
        repo=${args[1]}
        workdir=${args[2]}
        if [[ -d $workdir ]]; then
            branch=$(git -C ${workdir} rev-parse --abbrev-ref HEAD)
            if [[ $branch != $branch_name ]]; then
                if git -C $workdir rev-parse --verify $branch_name >/dev/null 2>&1; then
                    if git -C $workdir checkout -q $branch_name --; then
                        info "$repo: [$branch] -> [$branch_name]"
                        checked=1
                    else
                        error "Failed to check out $repo[$branch_name]"
                    fi
                fi
            else
                checked=1
            fi
        fi
    done
    if [[ $checked == 0 ]]; then
        warn "No any repository has branch named $branch_name"
    fi
}

disable_ipv6() {
    disable=$(cat /proc/sys/net/ipv6/conf/all/disable_ipv6)
    if [[ $disable == 0 ]]; then
        cp /etc/sysctl.conf /tmp/sysctl.conf
        sed -i "/net.ipv6.conf.all.disable_ipv6/ d" /tmp/sysctl.conf
        sed -i "/net.ipv6.conf.default.disable_ipv6/ d" /tmp/sysctl.conf
        sed -i "/net.ipv6.conf.lo.disable_ipv6/ d" /tmp/sysctl.conf
        echo "net.ipv6.conf.all.disable_ipv6 = 1" >>/tmp/sysctl.conf
        echo "net.ipv6.conf.default.disable_ipv6 = 1" >>/tmp/sysctl.conf
        echo "net.ipv6.conf.lo.disable_ipv6 = 1" >>/tmp/sysctl.conf
        $SUDO cp /etc/sysctl.conf /etc/sysctl.conf.orig
        $SUDO cp /tmp/sysctl.conf /etc/sysctl.conf
        $SUDO sysctl -p
        disable=$(cat /proc/sys/net/ipv6/conf/all/disable_ipv6)
        if [[ $disable == 1 ]]; then
            info "IPv6 is disabled"
        fi
    else
        info "IPv6 is already disabled"
    fi
}

_init_vncpasswd() {
    if [[ -f ~/.hr/.vncpasswd ]]; then
        password_file=~/.hr/.vncpasswd
    else
        password_file=$HR_PREFIX/hrtool/vncpasswd
    fi
    if [[ ! -f $password_file ]]; then
        password_file=~/.hr/.vncpasswd
        ${HR_PREFIX}/bin/vncpasswd $password_file
    fi
}

vncpasswd0() {
    local password_file=~/.hr/.vncpasswd
    ${HR_PREFIX}/bin/vncpasswd $password_file
}

vncserver0() {
    local password_file
    if [[ ! -f ${HR_PREFIX}/bin/x0vncserver ]]; then
        install_head-tigervnc
    fi
    _init_vncpasswd
    DISPLAY=${DISPLAY-:0} ${HR_PREFIX}/bin/x0vncserver -rfbauth $password_file $@
}

vncviewer0() {
    local password_file
    if [[ ! -f ${HR_PREFIX}/bin/vncviewer ]]; then
        install_head-tigervnc
    fi
    _init_vncpasswd
    DISPLAY=${DISPLAY-:0} ${HR_PREFIX}/bin/vncviewer -passwd $password_file $@
}

############# End of Functions #############

############# Main #############
show_help() {
cat << EOF
Hanson Robotics Software Management Tool

Usage: hr <command> [<args>]

  Supported commands:

    init [workspace]                        Init HR workspace. The default is ~/hansonrobotics
    install <component> [<component>] ...   Install components
    uninstall <component> [<component>] ... Uninstall components
    build <component> [<component>] ...     Build components
    update <component> [<component>] ...    Update components
    clean <component> [<component>] ...     Clean up components
    cmd <function> [<args>]                 Run any pre-defined function
    run [robot name] [arguments]            Run robot
    stop                                    Stop robot
    env                                     Show HR environment variables
    role                                    Set HR role
    version                                 Show version
    python                                  Run HEAD Python interpreter
    python3                                 Run HEAD Python3 interpreter
    fetch                                   Fetch source code (without updating repository)
    rebase                                  Run git rebase on current branch for all the source code (often used after hr fetch)

EOF
}

execute() {
    case "$1" in
        install|uninstall|build|cmd|init|clean|env|update|run|stop|version|role|python|python3|fetch|rebase)
            command=$1
            shift
            hr_${command} $@
            ;;
        *)
            warn "Unknown argument $1"
            show_help
            exit 1
            ;;
    esac
}

if [[ ! ${OS_VERSION} == "trusty" && ! ${OS_VERSION} == "xenial" ]]; then
    error "Error: Only Ubuntu 14.04 (trusty) and Ubuntu 16.04 (xenial) are supported" >&2
    exit 1
fi

export -f _get_repo _fetch_repo read_workspace _parse_repo_string clone info warn error
if [[ ! $(readlink -f ${BASH_SOURCE[0]}) == $(readlink -f $0) ]]; then return; fi
if [[ $# == 0 ]]; then show_help; exit 0; fi
execute $@
############# End of Main #############
